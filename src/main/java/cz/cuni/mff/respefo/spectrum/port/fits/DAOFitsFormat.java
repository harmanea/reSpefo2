package cz.cuni.mff.respefo.spectrum.port.fits;

import cz.cuni.mff.respefo.exception.InvalidFileFormatException;
import cz.cuni.mff.respefo.exception.SpefoException;
import cz.cuni.mff.respefo.spectrum.Spectrum;
import cz.cuni.mff.respefo.spectrum.format.SimpleSpectrum;
import cz.cuni.mff.respefo.util.collections.DoubleArrayList;
import cz.cuni.mff.respefo.util.collections.FitsFile;
import cz.cuni.mff.respefo.util.collections.XYSeries;
import cz.cuni.mff.respefo.util.utils.MathUtils;
import nom.tam.fits.Header;
import nom.tam.fits.HeaderCard;
import nom.tam.fits.header.Standard;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeFormatterBuilder;
import java.time.temporal.ChronoField;
import java.util.stream.IntStream;

import static java.lang.String.format;

public class DAOFitsFormat extends ImportFitsFormat {
    private static final DateTimeFormatter DATE_FORMATTER = new DateTimeFormatterBuilder()
            .appendValueReduced(ChronoField.YEAR, 2, 2, 1900)
            .appendPattern("/MM/dd")
            .toFormatter();

    private static final DateTimeFormatter TIME_FORMATTER = DateTimeFormatter.ofPattern("H:mm:ss.SS");

    private static final DateTimeFormatter OTHER_DATE_FORMATTER = new DateTimeFormatterBuilder()
            .appendPattern("MM/")
            .appendValueReduced(ChronoField.YEAR, 2, 2, 1900)
            .appendPattern(" /dd")
            .toFormatter();

    @Override
    protected Spectrum createSpectrum(FitsFile fits) throws SpefoException {
        Object data = fits.getData();
        if (data == null || !data.getClass().isArray()) {
            throw new InvalidFileFormatException("The HDU does not contain array data");
        }

        double[] ySeries = getSeriesFromData(data, fits.getBitpix());
        double[] coefficients = getCoefficients(fits.getHeader());
        if (coefficients.length == 0) {
            throw new InvalidFileFormatException("The FITS header does not contain any dispersion coefficients.");
        }

        double[] xSeries = IntStream.range(0, ySeries.length)
                .mapToDouble(i -> MathUtils.polynomial(i, coefficients))
                .toArray();

        XYSeries series = new XYSeries(xSeries, ySeries);
        return new SimpleSpectrum(series);
    }

    private static double[] getCoefficients(Header header) {
        DoubleArrayList coefficients = new DoubleArrayList();

        String key = "DCOEF1";
        for (int i = 1; header.containsKey(key); i++, key = format("DCOEF%d", i)) {
            double c = header.getDoubleValue(key);
            coefficients.add(c);
        }

        return coefficients.toArray();
    }

    @Override
    public LocalDateTime getDateOfObservation(Header header) {
        HeaderCard dateCard = header.getCard(Standard.DATE_OBS);

        String dateValue = dateCard.getValue();
        String timeValue = header.getStringValue("UT");
        LocalDateTime dateTime = parseDateAndTime(dateValue, timeValue);
        if (dateTime != null) {
            return dateTime;
        }

        String dateComment = dateCard.getComment();
        dateTime = parseDateCommentAndTime(dateValue, dateComment, timeValue);
        if (dateTime != null) {
            return dateTime;
        }

        return super.getDateOfObservation(header);
    }

    private static LocalDateTime parseDateAndTime(String dateValue, String timeValue) {
        try {
            LocalDate localDate = LocalDate.parse(dateValue, DATE_FORMATTER);
            LocalTime localTime = LocalTime.parse(timeValue.trim(), TIME_FORMATTER);

            return localDate.atTime(localTime);

        } catch (Exception exception) {
            return null;
        }
    }

    private static LocalDateTime parseDateCommentAndTime(String dateValue, String dateComment, String timeValue) {
        try {
            LocalDate localDate = LocalDate.parse(dateComment + dateValue, OTHER_DATE_FORMATTER);
            LocalTime localTime = LocalTime.parse(timeValue);

            return localDate.atTime(localTime);

        } catch (Exception exception) {
            return null;
        }
    }

    @Override
    public String name() {
        return "DAO";
    }

    @Override
    public String description() {
        return "The DAO FITS format.\n\n" +
                "It is very similar to the default FITS format, but may use a non-standard way of storing the date of observation. Spectra imported using this format are required to have dispersion coefficients stored in the header as generated by the 'Derive Dispersion' function.\n\n" +
                "This format is used by the Dominion Astrophysical Observatory (DAO) research facility.";
    }

    @Override
    public boolean isDefault() {
        return false;
    }
}
